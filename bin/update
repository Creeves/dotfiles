#!/usr/bin/env bash

# Here we ensure that the user has git installed
if [ ! $(type -P git) ]; then
    exit
fi

# Here we output a teal log message
function log() {
    printf "$(tput setaf 6)%s$(tput sgr0)\n" "$@"
}

# Here we create a method that will do the grunt work of our updates
function do_update() {

    # Log out the fact that we are updating the repo
    log "Updating \"$PWD\""

    # Update the repo
    ORIGINAL=`git rev-parse --abbrev-ref HEAD`

    # Here we fetch all branches
    git fetch --all

    # Next we loop over the branches, check them out, and perform a `git pull`
    for branch in "$@"; do
        if ["$branch" -ne "$ORIGINAL"]; then
            git checkout "$branch"
            git pull --progress --verbose
        fi
    done

    # Now we can checkout the branch that we had checked out when we first ran
    # this method
    git checkout "$ORIGINAL"
    git pull --progress --verbose

    # If a .gitmodules file is detected, update the submodules
    if [ -f .gitmodules ]; then
        git submodule update --recursive --init
    fi

}

# If we are inside a git repo we will update on this directory
if [ -d .git ]; then

    # Since we are in a git repo, lets just update away
    do_update

# It looks like this directory is not a git repo, lets check its children
else

    # Here we loop over the contents of this directory
    for path in ./*; do

        # Here we test to see if the item that we have found is in fact a
        # directory, and if it is, then we will cd into it.
        if [ -d $path ]; then

            # Now we can navigate into the directory in question
            cd $path

            # Now lets test to see if this is in fact a ".git" directory
            if [ -d .git ]; then

                # Since we have a repo, let's update it
                do_update

            fi

            # Lets go back up a directory so that our loop can continue
            cd ..
        fi

    # And finally, our loop is done
    done

fi

# vim: set syn=sh :
